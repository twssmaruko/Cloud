{"ast":null,"code":"import { compute as e } from \"compute-scroll-into-view\";\n\nconst o = e => !1 === e ? {\n  block: \"end\",\n  inline: \"nearest\"\n} : (e => e === Object(e) && 0 !== Object.keys(e).length)(e) ? e : {\n  block: \"start\",\n  inline: \"nearest\"\n};\n\nfunction t(t, n) {\n  if (!t.isConnected || !(e => {\n    let o = e;\n\n    for (; o && o.parentNode;) {\n      if (o.parentNode === document) return !0;\n      o = o.parentNode instanceof ShadowRoot ? o.parentNode.host : o.parentNode;\n    }\n\n    return !1;\n  })(t)) return;\n  if ((e => \"object\" == typeof e && \"function\" == typeof e.behavior)(n)) return n.behavior(e(t, n));\n  const r = \"boolean\" == typeof n || null == n ? void 0 : n.behavior;\n\n  for (const {\n    el: i,\n    top: a,\n    left: l\n  } of e(t, o(n))) i.scroll({\n    top: a,\n    left: l,\n    behavior: r\n  });\n}\n\nexport { t as default };","map":{"version":3,"mappings":";;AAgDA,MAUMA,IAAcC,MAEF,CAFEA,KAEdA,CAFcA,GAGT;AAAEC,SAAO,KAAT;AAAgBC,UAAQ;AAAxB,CAHSF,GATlBA,MAEAA,MAAYG,OAAOH,CAAPG,CAAZH,IAA+D,MAAhCG,OAAOC,IAAPD,CAAYH,CAAZG,EAAqBE,MAFpDL,EAe6BA,CAf7BA,IAiBSA,CAjBTA,GAqBO;AAAEC,SAAO,OAAT;AAAkBC,UAAQ;AAA1B,CAtBT;;AAwEA,SAASI,CAAT,CACEC,CADF,EAEEP,CAFF,EAEEA;AAGA,OAAKO,EAAOC,WAAZ,IAAYA,CAjDQC;AACpB,QAAIC,IAAiBD,CAArB;;AACO,gBAAkBC,EAAeC,UAAjC,GAA6C;AAC9C,YAAeA,UAAfD,KAA8BE,QAA9B,EACK;AAEPF,UADSA,EAAeC,UAAfD,YAAqCG,UAArCH,GACSA,EAAeC,UAAfD,CAAyCI,IADlDJ,GAGQA,EAAeC,UAFhCD;AAKG;;AAAA;AAAA,GAXaD,EAiDqBF,CAjDrBE,CAiDpB,EACE;AAGE,MA3EJT,MAEmB,mBAAZA,CAAY,IAAuC,qBAArBA,EAAQe,QAF7Cf,EA2E8BA,CA3E9BA,CA2EI,EACF,OAAOA,EAAQe,QAARf,CAAiBgB,EAAQT,CAARS,EAAgBhB,CAAhBgB,CAAjBhB,CAAP;AAGF,QAAMe,IAA8B,oBAAZf,CAAY,IAAiC,QAATA,CAAxB,GAAwBA,KAAZ,CAAZ,GAAiCA,UAArE;;AAEW;AAAAiB,QAAEA,CAAF;AAAMC,UAAN;AAAMC,UAAKA;AAAX,OAAqBH,EAAQT,CAARS,EAAgBjB,EAAWC,CAAXD,CAAhBiB,CAArB,EACTC,EAAGG,MAAHH,CAAU;AAAEC,UAAF;AAAOC,WAAP;AAAaJ;AAAb,GAAVE;AAEJ;;AAAA","names":["getOptions","options","block","inline","Object","keys","length","scrollIntoView","target","isConnected","element","currentElement","parentNode","document","ShadowRoot","host","behavior","compute","el","top","left","scroll"],"sources":["C:\\Users\\tanma\\Desktop\\AUT\\INFS803\\Project\\Cloud-Computing\\NewFrontEnd\\node_modules\\scroll-into-view-if-needed\\src\\index.ts"],"sourcesContent":["import { compute } from 'compute-scroll-into-view'\nimport type {\n  Options as BaseOptions,\n  ScrollAction,\n} from 'compute-scroll-into-view'\n\n/** @public */\nexport type Options<T = unknown> =\n  | StandardBehaviorOptions\n  | CustomBehaviorOptions<T>\n\n/**\n * Only scrolls if the `node` is partially out of view:\n * ```ts\n * scrollIntoView(node, { scrollMode: 'if-needed' })\n * ```\n * Skips scrolling `overflow: hidden` elements:\n * ```ts\n * scrollIntoView(node, { skipOverflowHiddenElements: true })\n * ```\n * When scrolling is needed do the least and smoothest scrolling possible:\n * ```ts\n * scrollIntoView(node, {\n *   behavior: 'smooth',\n *   scrollMode: 'if-needed',\n *   block: 'nearest',\n *   inline: 'nearest',\n * })\n * ```\n * @public\n */\nexport interface StandardBehaviorOptions extends BaseOptions {\n  /**\n   * @defaultValue 'auto\n   */\n  behavior?: ScrollBehavior\n}\n\n/** @public */\nexport interface CustomBehaviorOptions<T = unknown> extends BaseOptions {\n  behavior: CustomScrollBehaviorCallback<T>\n}\n\n/** @public */\nexport type CustomScrollBehaviorCallback<T = unknown> = (\n  actions: ScrollAction[]\n) => T\n\nconst isStandardScrollBehavior = (\n  options: any\n): options is StandardBehaviorOptions =>\n  options === Object(options) && Object.keys(options).length !== 0\n\nconst isCustomScrollBehavior = <T = unknown>(\n  options: any\n): options is CustomBehaviorOptions<T> =>\n  typeof options === 'object' ? typeof options.behavior === 'function' : false\n\nconst getOptions = (options: any): StandardBehaviorOptions => {\n  // Handle alignToTop for legacy reasons, to be compatible with the spec\n  if (options === false) {\n    return { block: 'end', inline: 'nearest' }\n  }\n\n  if (isStandardScrollBehavior(options)) {\n    // compute.ts ensures the defaults are block: 'center' and inline: 'nearest', to conform to the spec\n    return options\n  }\n\n  // if options = {}, options = true or options = null, based on w3c web platform test\n  return { block: 'start', inline: 'nearest' }\n}\n\n// Determine if the element is part of the document (including shadow dom)\n// Derived from code of Andy Desmarais\n// https://terodox.tech/how-to-tell-if-an-element-is-in-the-dom-including-the-shadow-dom/\nconst isInDocument = (element: Node) => {\n  let currentElement = element\n  while (currentElement && currentElement.parentNode) {\n    if (currentElement.parentNode === document) {\n      return true\n    } else if (currentElement.parentNode instanceof ShadowRoot) {\n      currentElement = (currentElement.parentNode as ShadowRoot).host\n    } else {\n      currentElement = currentElement.parentNode\n    }\n  }\n  return false\n}\n\n/**\n * Scrolls the given element into view, with options for when, and how.\n * Supports the same `options` as [`Element.prototype.scrollIntoView`](https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView) with additions such as `scrollMode`, `behavior: Function` and `skipOverflowHiddenElements`.\n * @public\n */\nfunction scrollIntoView(\n  target: Element,\n  options?: StandardBehaviorOptions | boolean\n): void\n/**\n * Scrolls the given element into view, with options for when, and how.\n * Supports the same `options` as [`Element.prototype.scrollIntoView`](https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView) with additions such as `scrollMode`, `behavior: Function` and `skipOverflowHiddenElements`.\n *\n * You can set the expected return type for `behavior: Function`:\n * ```ts\n * await scrollIntoView<Promise<boolean[]>>(node, {\n *   behavior: async actions => {\n *     return Promise.all(actions.map(\n *       // animate() resolves to `true` if anything was animated, `false` if the element already were in the end state\n *       ({ el, left, top }) => animate(el, {scroll: {left, top}})\n *     ))\n *   }\n * })\n * ```\n * @public\n */\nfunction scrollIntoView<T>(\n  target: Element,\n  options: CustomBehaviorOptions<T>\n): T\nfunction scrollIntoView<T = unknown>(\n  target: Element,\n  options?: StandardBehaviorOptions | CustomBehaviorOptions<T> | boolean\n): T | void {\n  // Browsers treats targets that aren't in the dom as a no-op and so should we\n  if (!target.isConnected || !isInDocument(target)) {\n    return\n  }\n\n  if (isCustomScrollBehavior<T>(options)) {\n    return options.behavior(compute(target, options))\n  }\n\n  const behavior = typeof options === 'boolean' ? undefined : options?.behavior\n\n  for (const { el, top, left } of compute(target, getOptions(options))) {\n    el.scroll({ top, left, behavior })\n  }\n}\n\nexport default scrollIntoView\n"]},"metadata":{},"sourceType":"module"}